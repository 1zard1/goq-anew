# Подробное объяснение технических понятий

## **CAP-теорема**
CAP-теорема формулирует ограничения для распределённых систем: нельзя одновременно достичь:
1. **Consistency (Согласованность):**
   Все узлы системы возвращают одинаковые данные, независимо от того, на каком узле был сделан запрос. Для обеспечения согласованности требуются:
   - Согласование данных через механизмы, такие как **Paxos**, **Raft** (распределённые консенсус-алгоритмы).
   - Жёсткий контроль версий данных через журналы репликации.

2. **Availability (Доступность):**
   Каждый запрос получает ответ, даже если узел не может гарантировать актуальность данных.
   - В основе — избыточность данных и механизмы фолловер-узлов.
   - Пример: в Cassandra каждое чтение может завершаться быстрее при слабых консистентных настройках (например, `QUORUM`, `ONE`).

3. **Partition Tolerance (Устойчивость к разделению сети):**
   Система остаётся работоспособной, несмотря на разделение сети (network partition).
   - Для этого используются репликация данных и изоляция подсистем, чтобы запросы обслуживались независимо от сетевых ошибок.

**Пример выбора:**
- **CP**: HBase, Zookeeper — жертвуют доступностью ради согласованности.
- **AP**: DynamoDB, Cassandra — жертвуют строгой консистентностью ради высокой доступности.

---

## **Принципы ACID**

Каждый принцип ACID детализируется конкретными механизмами, используемыми в СУБД:

1. **Atomicity (Атомарность):**
   - Реализуется через механизмы **Write Ahead Log (WAL)**, где изменения сначала записываются в лог, а затем применяются к данным.
   - Если транзакция прервана, изменения откатываются, используя **undo logs**.

2. **Consistency (Согласованность):**
   - Выполнение транзакции поддерживает целостность данных. Например, проверка ограничений (`CHECK`, `FOREIGN KEY`) до фиксации (`COMMIT`).
   - Пример: обновление счёта в банковской системе должно быть валидным по всем проверкам целостности.

3. **Isolation (Изолированность):**
   - Чаще реализуется через **MVCC (Multi-Version Concurrency Control)**:
     - Каждая транзакция видит "снимок" данных, существовавший на момент её начала.
     - Обновления записываются в новую версию данных, старые версии остаются доступными для других транзакций.
   - Альтернатива — блокировки:
     - **Shared Lock (S)** для чтения.
     - **Exclusive Lock (X)** для записи.

4. **Durability (Долговечность):**
   - Гарантируется записью данных в журнал перед ответом клиенту. Используются системные вызовы, такие как `fsync` или `fdatasync`.

---

## **Первичный и вторичный ключи**

1. **Первичный ключ (Primary Key):**
   - Под капотом: создаётся уникальный индекс (обычно кластеризованный).
   - Гарантирует уникальность строки в таблице.
   - **Влияние на производительность:**
     - Быстрое нахождение строки по ключу.
     - Замедление операций вставки из-за поддержания индекса.

2. **Вторичный ключ (Foreign Key):**
   - Контролирует целостность данных, ссылаясь на первичный ключ другой таблицы.
   - При вставке или удалении записей выполняются проверки через индексы.

**Пример PostgreSQL:**
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id) ON DELETE CASCADE
);
```
Здесь ON DELETE CASCADE обеспечивает автоматическое удаление связанных записей.

## **Составной ключ**

Составной ключ состоит из нескольких колонок. СУБД создаёт составной индекс, который хранит уникальные комбинации значений:
```sql
CREATE TABLE attendance (
    student_id INT,
    course_id INT,
    attendance_date DATE,
    PRIMARY KEY (student_id, course_id, attendance_date)
);
```


-  В данном случае комбинация student_id, course_id и attendance_date уникальна.
-  Для поиска строки используется составной индекс (B-Tree).

## **Индекс**
### Индекс — это вспомогательная структура данных, оптимизирующая запросы.

- Индексы хранят ключи и указатели на строки данных.
- Ускоряют операции чтения (SELECT) за счёт уменьшения числа обрабатываемых строк.
- Замедляют операции записи (INSERT, UPDATE, DELETE), так как требуют обновления индекса.

## **Кластеризованный и некластеризованный индекс**
#**1. Кластеризованный индекс:**
  - Строки данных физически отсортированы в соответствии с индексом.
  - Может быть только один, так как порядок строк в таблице единственный.
  - Используется для диапазонных запросов, например:
```sql
SELECT * FROM orders WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31';
```

#**2. Некластеризованный индекс:**
  - Хранит только указатели (rowid) на данные.
  - Подходит для уникальных и выборочных запросов.
```sql
CREATE INDEX idx_user_email ON users(email);
```


## **Типы индексов:**
1. B-Tree:
  - Подходит для большинства операций, включая диапазонные запросы.
  - Данные распределяются по страницам (pages) и поддерживаются сбалансированными через ротацию узлов.
2. Hash:
  - Для точных соответствий (=).
  - Неэффективен для диапазонных запросов.
3. GiST:
  - Используется для работы со сложными структурами данных (геометрия, полнотекстовые поиски).
4. GIN:
  - Для массивов, JSON и текстового поиска.
  - Создаёт инвертированный индекс для поиска по множествам значений.

## **Транзакции и SELECT FOR:**
- Транзакции группируют операции, чтобы они выполнялись атомарно.
  - WAL (Write-Ahead Logging): изменения записываются в журнал перед фактической фиксацией.
  - SELECT FOR используется для предотвращения изменения строк другими транзакциями. Пример:
```sql
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
```
- Под капотом: строка блокируется эксклюзивной блокировкой (Exclusive Lock).

## **Уровни изоляции**
1. Read Uncommitted: видны незавершённые изменения.
2. Read Committed: предотвращает грязное чтение, но допускает фантомные.
3. Repetable Read: предотвращает неповторяющееся чтение, но не фантомное.
4. Serializable: полная изоляция, симулирует последовательное выполнение.
- Пример: Два потока обновляют остаток на складе. Если изоляция ниже Repeatable Read, может быть выполнено два обновления с неверным результатом.

## **Оптимизация запросов и EXPLAIN**
1. EXPLAIN показывает план выполнения запроса, включая:
- Типы сканирования (Sequential Scan, Index Scan, Bitmap Scan).
- Кардинальность (число строк).
- Оценка стоимости (cost): расчёт времени выполнения.
2. EXPLAIN ANALYZE: запускает запрос и показывает фактические данные о выполнении:
- Фактическое количество строк.
- Затраты на каждую операцию.
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE order_date > '2025-01-01';
```
- Покажет, используется ли индекс.
- Определяет узкие места, например, неэффективные последовательные сканирования (Seq Scan).
